"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlockSymbolTable = exports.ProgramSymbolTable = exports.SymbolTable = undefined;

var _util = require("@glimmer/util");

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);for (var i = 0; i < keys.length; i++) {
        var key = keys[i];var value = Object.getOwnPropertyDescriptor(defaults, key);if (value && value.configurable && obj[key] === undefined) {
            Object.defineProperty(obj, key, value);
        }
    }return obj;
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var SymbolTable = exports.SymbolTable = function () {
    function SymbolTable() {
        _classCallCheck(this, SymbolTable);
    }

    SymbolTable.top = function top() {
        return new ProgramSymbolTable();
    };

    SymbolTable.prototype.child = function child(locals) {
        var _this = this;

        var symbols = locals.map(function (name) {
            return _this.allocate(name);
        });
        return new BlockSymbolTable(this, locals, symbols);
    };

    return SymbolTable;
}();
var ProgramSymbolTable = exports.ProgramSymbolTable = function (_SymbolTable) {
    _inherits(ProgramSymbolTable, _SymbolTable);

    function ProgramSymbolTable() {
        _classCallCheck(this, ProgramSymbolTable);

        var _this2 = _possibleConstructorReturn(this, _SymbolTable.apply(this, arguments));

        _this2.symbols = [];
        _this2.size = 1;
        _this2.named = (0, _util.dict)();
        _this2.blocks = (0, _util.dict)();
        return _this2;
    }

    ProgramSymbolTable.prototype.has = function has(_name) {
        return false;
    };

    ProgramSymbolTable.prototype.get = function get(_name) {
        throw (0, _util.unreachable)();
    };

    ProgramSymbolTable.prototype.getLocalsMap = function getLocalsMap() {
        return {};
    };

    ProgramSymbolTable.prototype.getEvalInfo = function getEvalInfo() {
        return [];
    };

    ProgramSymbolTable.prototype.allocateNamed = function allocateNamed(name) {
        var named = this.named[name];
        if (!named) {
            named = this.named[name] = this.allocate(name);
        }
        return named;
    };

    ProgramSymbolTable.prototype.allocateBlock = function allocateBlock(name) {
        var block = this.blocks[name];
        if (!block) {
            block = this.blocks[name] = this.allocate('&' + name);
        }
        return block;
    };

    ProgramSymbolTable.prototype.allocate = function allocate(identifier) {
        this.symbols.push(identifier);
        return this.size++;
    };

    return ProgramSymbolTable;
}(SymbolTable);
var BlockSymbolTable = exports.BlockSymbolTable = function (_SymbolTable2) {
    _inherits(BlockSymbolTable, _SymbolTable2);

    function BlockSymbolTable(parent, symbols, slots) {
        _classCallCheck(this, BlockSymbolTable);

        var _this3 = _possibleConstructorReturn(this, _SymbolTable2.call(this));

        _this3.parent = parent;
        _this3.symbols = symbols;
        _this3.slots = slots;
        return _this3;
    }

    BlockSymbolTable.prototype.has = function has(name) {
        return this.symbols.indexOf(name) !== -1 || this.parent.has(name);
    };

    BlockSymbolTable.prototype.get = function get(name) {
        var slot = this.symbols.indexOf(name);
        return slot === -1 ? this.parent.get(name) : this.slots[slot];
    };

    BlockSymbolTable.prototype.getLocalsMap = function getLocalsMap() {
        var _this4 = this;

        var dict = this.parent.getLocalsMap();
        this.symbols.forEach(function (symbol) {
            return dict[symbol] = _this4.get(symbol);
        });
        return dict;
    };

    BlockSymbolTable.prototype.getEvalInfo = function getEvalInfo() {
        var locals = this.getLocalsMap();
        return Object.keys(locals).map(function (symbol) {
            return locals[symbol];
        });
    };

    BlockSymbolTable.prototype.allocateNamed = function allocateNamed(name) {
        return this.parent.allocateNamed(name);
    };

    BlockSymbolTable.prototype.allocateBlock = function allocateBlock(name) {
        return this.parent.allocateBlock(name);
    };

    BlockSymbolTable.prototype.allocate = function allocate(identifier) {
        return this.parent.allocate(identifier);
    };

    return BlockSymbolTable;
}(SymbolTable);
/**
 * Takes in an AST and outputs a list of actions to be consumed
 * by a compiler. For example, the template
 *
 *     foo{{bar}}<div>baz</div>
 *
 * produces the actions
 *
 *     [['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 3]],
 *      ['mustache', [mustacheNode, 1, 3]],
 *      ['openElement', [elementNode, 2, 3, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['closeElement', [elementNode, 2, 3],
 *      ['endProgram', [programNode]]]
 *
 * This visitor walks the AST depth first and backwards. As
 * a result the bottom-most child template will appear at the
 * top of the actions list whereas the root template will appear
 * at the bottom of the list. For example,
 *
 *     <div>{{#if}}foo{{else}}bar<b></b>{{/if}}</div>
 *
 * produces the actions
 *
 *     [['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 2, 0]],
 *      ['openElement', [elementNode, 1, 2, 0]],
 *      ['closeElement', [elementNode, 1, 2]],
 *      ['endProgram', [programNode]],
 *      ['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['endProgram', [programNode]],
 *      ['startProgram', [programNode, 2]],
 *      ['openElement', [elementNode, 0, 1, 1]],
 *      ['block', [blockNode, 0, 1]],
 *      ['closeElement', [elementNode, 0, 1]],
 *      ['endProgram', [programNode]]]
 *
 * The state of the traversal is maintained by a stack of frames.
 * Whenever a node with children is entered (either a ProgramNode
 * or an ElementNode) a frame is pushed onto the stack. The frame
 * contains information about the state of the traversal of that
 * node. For example,
 *
 *   - index of the current child node being visited
 *   - the number of mustaches contained within its child nodes
 *   - the list of actions generated by its child nodes
 */

var Frame = function Frame() {
    _classCallCheck(this, Frame);

    this.parentNode = null;
    this.children = null;
    this.childIndex = null;
    this.childCount = null;
    this.childTemplateCount = 0;
    this.mustacheCount = 0;
    this.actions = [];
    this.blankChildTextNodes = null;
    this.symbols = null;
};

var TemplateVisitor = function () {
    function TemplateVisitor() {
        _classCallCheck(this, TemplateVisitor);

        this.frameStack = [];
        this.actions = [];
        this.programDepth = -1;
    }

    TemplateVisitor.prototype.visit = function visit(node) {
        this[node.type](node);
    };
    // Traversal methods


    TemplateVisitor.prototype.Program = function Program(program) {
        var _actions;

        this.programDepth++;
        var parentFrame = this.getCurrentFrame();
        var programFrame = this.pushFrame();
        if (!parentFrame) {
            program['symbols'] = SymbolTable.top();
        } else {
            program['symbols'] = parentFrame.symbols.child(program.blockParams);
        }
        var startType = void 0,
            endType = void 0;
        if (this.programDepth === 0) {
            startType = 'startProgram';
            endType = 'endProgram';
        } else {
            startType = 'startBlock';
            endType = 'endBlock';
        }
        programFrame.parentNode = program;
        programFrame.children = program.body;
        programFrame.childCount = program.body.length;
        programFrame.blankChildTextNodes = [];
        programFrame.actions.push([endType, [program, this.programDepth]]);
        programFrame.symbols = program['symbols'];
        for (var i = program.body.length - 1; i >= 0; i--) {
            programFrame.childIndex = i;
            this.visit(program.body[i]);
        }
        programFrame.actions.push([startType, [program, programFrame.childTemplateCount, programFrame.blankChildTextNodes.reverse()]]);
        this.popFrame();
        this.programDepth--;
        // Push the completed template into the global actions list
        if (parentFrame) {
            parentFrame.childTemplateCount++;
        }
        (_actions = this.actions).push.apply(_actions, programFrame.actions.reverse());
    };

    TemplateVisitor.prototype.ElementNode = function ElementNode(element) {
        var _parentFrame$actions;

        var parentFrame = this.currentFrame;
        var elementFrame = this.pushFrame();
        elementFrame.parentNode = element;
        elementFrame.children = element.children;
        elementFrame.childCount = element.children.length;
        elementFrame.mustacheCount += element.modifiers.length;
        elementFrame.blankChildTextNodes = [];
        elementFrame.symbols = element['symbols'] = parentFrame.symbols.child(element.blockParams);
        var actionArgs = [element, parentFrame.childIndex, parentFrame.childCount];
        elementFrame.actions.push(['closeElement', actionArgs]);
        for (var i = element.attributes.length - 1; i >= 0; i--) {
            this.visit(element.attributes[i]);
        }
        for (var _i = element.children.length - 1; _i >= 0; _i--) {
            elementFrame.childIndex = _i;
            this.visit(element.children[_i]);
        }
        var open = ['openElement', [].concat(actionArgs, [elementFrame.mustacheCount, elementFrame.blankChildTextNodes.reverse()])];
        elementFrame.actions.push(open);
        this.popFrame();
        // Propagate the element's frame state to the parent frame
        if (elementFrame.mustacheCount > 0) {
            parentFrame.mustacheCount++;
        }
        parentFrame.childTemplateCount += elementFrame.childTemplateCount;
        (_parentFrame$actions = parentFrame.actions).push.apply(_parentFrame$actions, elementFrame.actions);
    };

    TemplateVisitor.prototype.AttrNode = function AttrNode(attr) {
        if (attr.value.type !== 'TextNode') {
            this.currentFrame.mustacheCount++;
        }
    };

    TemplateVisitor.prototype.TextNode = function TextNode(text) {
        var frame = this.currentFrame;
        if (text.chars === '') {
            frame.blankChildTextNodes.push(domIndexOf(frame.children, text));
        }
        frame.actions.push(['text', [text, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.BlockStatement = function BlockStatement(node) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['block', [node, frame.childIndex, frame.childCount]]);
        if (node.inverse) {
            this.visit(node.inverse);
        }
        if (node.program) {
            this.visit(node.program);
        }
    };

    TemplateVisitor.prototype.PartialStatement = function PartialStatement(node) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [node, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.CommentStatement = function CommentStatement(text) {
        var frame = this.currentFrame;
        frame.actions.push(['comment', [text, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.MustacheCommentStatement = function MustacheCommentStatement() {
        // Intentional empty: Handlebars comments should not affect output.
    };

    TemplateVisitor.prototype.MustacheStatement = function MustacheStatement(mustache) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [mustache, frame.childIndex, frame.childCount]]);
    };
    // Frame helpers


    TemplateVisitor.prototype.getCurrentFrame = function getCurrentFrame() {
        return this.frameStack[this.frameStack.length - 1];
    };

    TemplateVisitor.prototype.pushFrame = function pushFrame() {
        var frame = new Frame();
        this.frameStack.push(frame);
        return frame;
    };

    TemplateVisitor.prototype.popFrame = function popFrame() {
        return this.frameStack.pop();
    };

    _createClass(TemplateVisitor, [{
        key: 'currentFrame',
        get: function get() {
            return this.getCurrentFrame();
        }
    }]);

    return TemplateVisitor;
}();
// Returns the index of `domNode` in the `nodes` array, skipping
// over any nodes which do not represent DOM nodes.


exports.default = TemplateVisitor;

function domIndexOf(nodes, domNode) {
    var index = -1;
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.type !== 'TextNode' && node.type !== 'ElementNode') {
            continue;
        } else {
            index++;
        }
        if (node === domNode) {
            return index;
        }
    }
    return -1;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGUtdmlzaXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi90ZW1wbGF0ZS12aXNpdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQSxBQUFPLEFBQWdCLEFBQUksQUFBRSxBQUFXLEFBQUUsQUFBTSxBQUFFLEFBQU0sQUFBZSxBQUFDLEFBRXhFLEFBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQWdCLEFBQVcsQUFDL0IsQUFBTTs7Ozs7Z0JBQUMsQUFBRyxxQkFDUjtlQUFPLElBQUksQUFBa0IsQUFBRSxBQUFDLEFBQ2xDLEFBQUMsQUFZRCxBQUFLOzs7aURBQUMsQUFBZ0IsUUFDcEI7OztZQUFJLEFBQU8saUJBQVUsQUFBRyxvQkFBQyxBQUFJLEFBQUMsQUFBRTttQkFBQyxBQUFJLE1BQUMsQUFBUSxTQUFDLEFBQUksQUFBQyxBQUFDLEFBQUMsQUFDdEQ7QUFEYyxBQUFNO2VBQ2IsSUFBSSxBQUFnQixpQkFBQyxBQUFJLE1BQUUsQUFBTSxRQUFFLEFBQU8sQUFBQyxBQUFDLEFBQ3JELEFBQUMsQUFDRjs7OztBQUVELEFBQU07SUFBTyxBQUFtQjs7Ozs7OytFQUN2Qjs7ZUFBTyxVQUFhLEFBQUUsQUFBQyxBQUV0QjtlQUFJLE9BQUcsQUFBQyxBQUFDLEFBQ1Q7ZUFBSyxRQUFHLEFBQUksQUFBVSxBQUFDLEFBQ3ZCO2VBQU0sU0FBRyxBQUFJLEFBQVUsQUFBQyxBQTBDbEMsQUFBQztlQXhDQyxBQUFHOzs7b0RBQUMsQUFBYSxPQUNmO2VBQU8sQUFBSyxBQUFDLEFBQ2YsQUFBQyxBQUVELEFBQUc7OztvREFBQyxBQUFhLE9BQ2Y7Y0FBTSxBQUFXLEFBQUUsQUFBQyxBQUN0QixBQUFDLEFBRUQsQUFBWTs7O3dFQUNWO2VBQU8sQUFBRSxBQUFDLEFBQ1osQUFBQyxBQUVELEFBQVc7OztzRUFDVDtlQUFPLEFB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QUMsQUFBVSxXQUFDLEFBQUcsQUFBRSxBQUFDLEFBQy9CLEFBQUMsQUFDRjs7Ozs7NEJBaEJHLEFBQU8sQUFBTTttQkFBQyxBQUFJLEtBQUMsQUFBZSxBQUFFLEFBQUUsQUFBMEIsQUFBQyxBQUFDLEFBQ3BFLEFBQUMsQUFFTyxBQUFlOzs7Ozs7QUFlekIsQUFBZ0U7QUFDaEUsQUFBbUQ7Ozs7O0FBQ25ELFNBQVMsQUFBVSxXQUFDLEFBQWlCLE9BQUUsQUFBdUMsU0FDNUU7UUFBSSxBQUFLLFFBQUcsQ0FBQyxBQUFDLEFBQUMsQUFFZjtTQUFLLElBQUksQUFBQyxJQUFHLEFBQUMsR0FBRSxBQUFDLElBQUcsQUFBSyxNQUFDLEFBQU0sUUFBRSxBQUFDLEFBQUUsS0FBRSxBQUNyQztZQUFJLEFBQUksT0FBRyxBQUFLLE1BQUMsQUFBQyxBQUFDLEFBQUMsQUFFcEI7WUFBSSxBQUFJLEtBQUMsQUFBSSxTQUFLLEFBQVUsY0FBSSxBQUFJLEtBQUMsQUFBSSxTQUFLLEFBQWEsZUFBRSxBQUMzRCxBQUFTLEFBQ1Y7O2VBQU0sQUFDTCxBQUFLLEFBQUUsQUFBQyxBQUNUO0FBRUQ7O1lBQUksQUFBSSxTQUFLLEFBQU8sU0FBRSxBQUNwQjttQkFBTyxBQUFLLEFBQUMsQUFDZCxBQUNGO0FBRUQ7O1dBQU8sQ0FBQyxBQUFDLEFBQUMsQUFDWixBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQVNUIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IENvcmUgfSBmcm9tICdAZ2xpbW1lci93aXJlLWZvcm1hdCc7XG5pbXBvcnQgeyBEaWN0LCBPcHRpb24sIGRpY3QsIHVucmVhY2hhYmxlLCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN5bWJvbFRhYmxlIHtcbiAgc3RhdGljIHRvcCgpOiBQcm9ncmFtU3ltYm9sVGFibGUge1xuICAgIHJldHVybiBuZXcgUHJvZ3JhbVN5bWJvbFRhYmxlKCk7XG4gIH1cblxuICBhYnN0cmFjdCBoYXMobmFtZTogc3RyaW5nKTogYm9vbGVhbjtcbiAgYWJzdHJhY3QgZ2V0KG5hbWU6IHN0cmluZyk6IG51bWJlcjtcblxuICBhYnN0cmFjdCBnZXRMb2NhbHNNYXAoKTogRGljdDxudW1iZXI+O1xuICBhYnN0cmFjdCBnZXRFdmFsSW5mbygpOiBDb3JlLkV2YWxJbmZvO1xuXG4gIGFic3RyYWN0IGFsbG9jYXRlTmFtZWQobmFtZTogc3RyaW5nKTogbnVtYmVyO1xuICBhYnN0cmFjdCBhbGxvY2F0ZUJsb2NrKG5hbWU6IHN0cmluZyk6IG51bWJlcjtcbiAgYWJzdHJhY3QgYWxsb2NhdGUoaWRlbnRpZmllcjogc3RyaW5nKTogbnVtYmVyO1xuXG4gIGNoaWxkKGxvY2Fsczogc3RyaW5nW10pOiBCbG9ja1N5bWJvbFRhYmxlIHtcbiAgICBsZXQgc3ltYm9scyA9IGxvY2Fscy5tYXAobmFtZSA9PiB0aGlzLmFsbG9jYXRlKG5hbWUpKTtcbiAgICByZXR1cm4gbmV3IEJsb2NrU3ltYm9sVGFibGUodGhpcywgbG9jYWxzLCBzeW1ib2xzKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJvZ3JhbVN5bWJvbFRhYmxlIGV4dGVuZHMgU3ltYm9sVGFibGUge1xuICBwdWJsaWMgc3ltYm9sczogc3RyaW5nW10gPSBbXTtcblxuICBwcml2YXRlIHNpemUgPSAxO1xuICBwcml2YXRlIG5hbWVkID0gZGljdDxudW1iZXI+KCk7XG4gIHByaXZhdGUgYmxvY2tzID0gZGljdDxudW1iZXI+KCk7XG5cbiAgaGFzKF9uYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQoX25hbWU6IHN0cmluZyk6IG5ldmVyIHtcbiAgICB0aHJvdyB1bnJlYWNoYWJsZSgpO1xuICB9XG5cbiAgZ2V0TG9jYWxzTWFwKCk6IERpY3Q8bnVtYmVyPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgZ2V0RXZhbEluZm8oKTogQ29yZS5FdmFsSW5mbyB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYWxsb2NhdGVOYW1lZChuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGxldCBuYW1lZCA9IHRoaXMubmFtZWRbbmFtZV07XG5cbiAgICBpZiAoIW5hbWVkKSB7XG4gICAgICBuYW1lZCA9IHRoaXMubmFtZWRbbmFtZV0gPSB0aGlzLmFsbG9jYXRlKG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lZDtcbiAgfVxuXG4gIGFsbG9jYXRlQmxvY2sobmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBsZXQgYmxvY2sgPSB0aGlzLmJsb2Nrc1tuYW1lXTtcblxuICAgIGlmICghYmxvY2spIHtcbiAgICAgIGJsb2NrID0gdGhpcy5ibG9ja3NbbmFtZV0gPSB0aGlzLmFsbG9jYXRlKGAmJHtuYW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiBibG9jaztcbiAgfVxuXG4gIGFsbG9jYXRlKGlkZW50aWZpZXI6IHN0cmluZyk6IG51bWJlciB7XG4gICAgdGhpcy5zeW1ib2xzLnB1c2goaWRlbnRpZmllcik7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSsrO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1N5bWJvbFRhYmxlIGV4dGVuZHMgU3ltYm9sVGFibGUge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBhcmVudDogU3ltYm9sVGFibGUsIHB1YmxpYyBzeW1ib2xzOiBzdHJpbmdbXSwgcHVibGljIHNsb3RzOiBudW1iZXJbXSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBoYXMobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3ltYm9scy5pbmRleE9mKG5hbWUpICE9PSAtMSB8fCB0aGlzLnBhcmVudC5oYXMobmFtZSk7XG4gIH1cblxuICBnZXQobmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBsZXQgc2xvdCA9IHRoaXMuc3ltYm9scy5pbmRleE9mKG5hbWUpO1xuICAgIHJldHVybiBzbG90ID09PSAtMSA/IHRoaXMucGFyZW50LmdldChuYW1lKSA6IHRoaXMuc2xvdHNbc2xvdF07XG4gIH1cblxuICBnZXRMb2NhbHNNYXAoKTogRGljdDxudW1iZXI+IHtcbiAgICBsZXQgZGljdCA9IHRoaXMucGFyZW50LmdldExvY2Fsc01hcCgpO1xuICAgIHRoaXMuc3ltYm9scy5mb3JFYWNoKHN5bWJvbCA9PiAoZGljdFtzeW1ib2xdID0gdGhpcy5nZXQoc3ltYm9sKSkpO1xuICAgIHJldHVybiBkaWN0O1xuICB9XG5cbiAgZ2V0RXZhbEluZm8oKTogQ29yZS5FdmFsSW5mbyB7XG4gICAgbGV0IGxvY2FscyA9IHRoaXMuZ2V0TG9jYWxzTWFwKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxvY2FscykubWFwKHN5bWJvbCA9PiBsb2NhbHNbc3ltYm9sXSk7XG4gIH1cblxuICBhbGxvY2F0ZU5hbWVkKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmFsbG9jYXRlTmFtZWQobmFtZSk7XG4gIH1cblxuICBhbGxvY2F0ZUJsb2NrKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmFsbG9jYXRlQmxvY2sobmFtZSk7XG4gIH1cblxuICBhbGxvY2F0ZShpZGVudGlmaWVyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hbGxvY2F0ZShpZGVudGlmaWVyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRha2VzIGluIGFuIEFTVCBhbmQgb3V0cHV0cyBhIGxpc3Qgb2YgYWN0aW9ucyB0byBiZSBjb25zdW1lZFxuICogYnkgYSBjb21waWxlci4gRm9yIGV4YW1wbGUsIHRoZSB0ZW1wbGF0ZVxuICpcbiAqICAgICBmb297e2Jhcn19PGRpdj5iYXo8L2Rpdj5cbiAqXG4gKiBwcm9kdWNlcyB0aGUgYWN0aW9uc1xuICpcbiAqICAgICBbWydzdGFydFByb2dyYW0nLCBbcHJvZ3JhbU5vZGUsIDBdXSxcbiAqICAgICAgWyd0ZXh0JywgW3RleHROb2RlLCAwLCAzXV0sXG4gKiAgICAgIFsnbXVzdGFjaGUnLCBbbXVzdGFjaGVOb2RlLCAxLCAzXV0sXG4gKiAgICAgIFsnb3BlbkVsZW1lbnQnLCBbZWxlbWVudE5vZGUsIDIsIDMsIDBdXSxcbiAqICAgICAgWyd0ZXh0JywgW3RleHROb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnY2xvc2VFbGVtZW50JywgW2VsZW1lbnROb2RlLCAyLCAzXSxcbiAqICAgICAgWydlbmRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlXV1dXG4gKlxuICogVGhpcyB2aXNpdG9yIHdhbGtzIHRoZSBBU1QgZGVwdGggZmlyc3QgYW5kIGJhY2t3YXJkcy4gQXNcbiAqIGEgcmVzdWx0IHRoZSBib3R0b20tbW9zdCBjaGlsZCB0ZW1wbGF0ZSB3aWxsIGFwcGVhciBhdCB0aGVcbiAqIHRvcCBvZiB0aGUgYWN0aW9ucyBsaXN0IHdoZXJlYXMgdGhlIHJvb3QgdGVtcGxhdGUgd2lsbCBhcHBlYXJcbiAqIGF0IHRoZSBib3R0b20gb2YgdGhlIGxpc3QuIEZvciBleGFtcGxlLFxuICpcbiAqICAgICA8ZGl2Pnt7I2lmfX1mb297e2Vsc2V9fWJhcjxiPjwvYj57ey9pZn19PC9kaXY+XG4gKlxuICogcHJvZHVjZXMgdGhlIGFjdGlvbnNcbiAqXG4gKiAgICAgW1snc3RhcnRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlLCAwXV0sXG4gKiAgICAgIFsndGV4dCcsIFt0ZXh0Tm9kZSwgMCwgMiwgMF1dLFxuICogICAgICBbJ29wZW5FbGVtZW50JywgW2VsZW1lbnROb2RlLCAxLCAyLCAwXV0sXG4gKiAgICAgIFsnY2xvc2VFbGVtZW50JywgW2VsZW1lbnROb2RlLCAxLCAyXV0sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dLFxuICogICAgICBbJ3N0YXJ0UHJvZ3JhbScsIFtwcm9ncmFtTm9kZSwgMF1dLFxuICogICAgICBbJ3RleHQnLCBbdGV4dE5vZGUsIDAsIDFdXSxcbiAqICAgICAgWydlbmRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlXV0sXG4gKiAgICAgIFsnc3RhcnRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlLCAyXV0sXG4gKiAgICAgIFsnb3BlbkVsZW1lbnQnLCBbZWxlbWVudE5vZGUsIDAsIDEsIDFdXSxcbiAqICAgICAgWydibG9jaycsIFtibG9ja05vZGUsIDAsIDFdXSxcbiAqICAgICAgWydjbG9zZUVsZW1lbnQnLCBbZWxlbWVudE5vZGUsIDAsIDFdXSxcbiAqICAgICAgWydlbmRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlXV1dXG4gKlxuICogVGhlIHN0YXRlIG9mIHRoZSB0cmF2ZXJzYWwgaXMgbWFpbnRhaW5lZCBieSBhIHN0YWNrIG9mIGZyYW1lcy5cbiAqIFdoZW5ldmVyIGEgbm9kZSB3aXRoIGNoaWxkcmVuIGlzIGVudGVyZWQgKGVpdGhlciBhIFByb2dyYW1Ob2RlXG4gKiBvciBhbiBFbGVtZW50Tm9kZSkgYSBmcmFtZSBpcyBwdXNoZWQgb250byB0aGUgc3RhY2suIFRoZSBmcmFtZVxuICogY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXRlIG9mIHRoZSB0cmF2ZXJzYWwgb2YgdGhhdFxuICogbm9kZS4gRm9yIGV4YW1wbGUsXG4gKlxuICogICAtIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoaWxkIG5vZGUgYmVpbmcgdmlzaXRlZFxuICogICAtIHRoZSBudW1iZXIgb2YgbXVzdGFjaGVzIGNvbnRhaW5lZCB3aXRoaW4gaXRzIGNoaWxkIG5vZGVzXG4gKiAgIC0gdGhlIGxpc3Qgb2YgYWN0aW9ucyBnZW5lcmF0ZWQgYnkgaXRzIGNoaWxkIG5vZGVzXG4gKi9cblxuY2xhc3MgRnJhbWUge1xuICBwdWJsaWMgcGFyZW50Tm9kZTogT3B0aW9uPE9iamVjdD4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRyZW46IE9wdGlvbjxBU1QuTm9kZVtdPiA9IG51bGw7XG4gIHB1YmxpYyBjaGlsZEluZGV4OiBPcHRpb248bnVtYmVyPiA9IG51bGw7XG4gIHB1YmxpYyBjaGlsZENvdW50OiBPcHRpb248bnVtYmVyPiA9IG51bGw7XG4gIHB1YmxpYyBjaGlsZFRlbXBsYXRlQ291bnQgPSAwO1xuICBwdWJsaWMgbXVzdGFjaGVDb3VudCA9IDA7XG4gIHB1YmxpYyBhY3Rpb25zOiBBY3Rpb25bXSA9IFtdO1xuICBwdWJsaWMgYmxhbmtDaGlsZFRleHROb2RlczogT3B0aW9uPG51bWJlcltdPiA9IG51bGw7XG4gIHB1YmxpYyBzeW1ib2xzOiBPcHRpb248U3ltYm9sVGFibGU+ID0gbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBBY3Rpb24ge1xuICBleHBvcnQgdHlwZSBTdGFydFByb2dyYW0gPSBbJ3N0YXJ0UHJvZ3JhbScsIFtBU1QuUHJvZ3JhbSwgbnVtYmVyLCBudW1iZXJbXV1dO1xuICBleHBvcnQgdHlwZSBFbmRQcm9ncmFtID0gWydlbmRQcm9ncmFtJywgW0FTVC5Qcm9ncmFtLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgU3RhcnRCbG9jayA9IFsnc3RhcnRCbG9jaycsIFtBU1QuUHJvZ3JhbSwgbnVtYmVyLCBudW1iZXJbXV1dO1xuICBleHBvcnQgdHlwZSBFbmRCbG9jayA9IFsnZW5kQmxvY2snLCBbQVNULlByb2dyYW0sIG51bWJlcl1dO1xuICBleHBvcnQgdHlwZSBCbG9jayA9IFsnYmxvY2snLCBbQVNULkJsb2NrU3RhdGVtZW50LCBudW1iZXIsIG51bWJlcl1dO1xuICBleHBvcnQgdHlwZSBNdXN0YWNoZSA9IFtcbiAgICAnbXVzdGFjaGUnLFxuICAgIFtBU1QuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1QuUGFydGlhbFN0YXRlbWVudCwgbnVtYmVyLCBudW1iZXJdXG4gIF07XG4gIGV4cG9ydCB0eXBlIE9wZW5FbGVtZW50ID0gWydvcGVuRWxlbWVudCcsIFtBU1QuRWxlbWVudE5vZGUsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcltdXV07XG4gIGV4cG9ydCB0eXBlIENsb3NlRWxlbWVudCA9IFsnY2xvc2VFbGVtZW50JywgW0FTVC5FbGVtZW50Tm9kZSwgbnVtYmVyLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgVGV4dCA9IFsndGV4dCcsIFtBU1QuVGV4dE5vZGUsIG51bWJlciwgbnVtYmVyXV07XG4gIGV4cG9ydCB0eXBlIENvbW1lbnQgPSBbJ2NvbW1lbnQnLCBbQVNULkNvbW1lbnRTdGF0ZW1lbnQsIG51bWJlciwgbnVtYmVyXV07XG5cbiAgZXhwb3J0IHR5cGUgQWN0aW9uID1cbiAgICB8IFN0YXJ0UHJvZ3JhbVxuICAgIHwgRW5kUHJvZ3JhbVxuICAgIHwgU3RhcnRCbG9ja1xuICAgIHwgRW5kQmxvY2tcbiAgICB8IEJsb2NrXG4gICAgfCBNdXN0YWNoZVxuICAgIHwgT3BlbkVsZW1lbnRcbiAgICB8IENsb3NlRWxlbWVudFxuICAgIHwgVGV4dFxuICAgIHwgQ29tbWVudDtcbn1cblxuZXhwb3J0IHR5cGUgQWN0aW9uID0gQWN0aW9uLkFjdGlvbjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVtcGxhdGVWaXNpdG9yIHtcbiAgcHJpdmF0ZSBmcmFtZVN0YWNrOiBGcmFtZVtdID0gW107XG4gIHB1YmxpYyBhY3Rpb25zOiBBY3Rpb25bXSA9IFtdO1xuICBwcml2YXRlIHByb2dyYW1EZXB0aCA9IC0xO1xuXG4gIHZpc2l0KG5vZGU6IEFTVC5CYXNlTm9kZSkge1xuICAgIHRoaXNbbm9kZS50eXBlXShub2RlKTtcbiAgfVxuXG4gIC8vIFRyYXZlcnNhbCBtZXRob2RzXG5cbiAgUHJvZ3JhbShwcm9ncmFtOiBBU1QuUHJvZ3JhbSkge1xuICAgIHRoaXMucHJvZ3JhbURlcHRoKys7XG5cbiAgICBsZXQgcGFyZW50RnJhbWUgPSB0aGlzLmdldEN1cnJlbnRGcmFtZSgpO1xuICAgIGxldCBwcm9ncmFtRnJhbWUgPSB0aGlzLnB1c2hGcmFtZSgpO1xuXG4gICAgaWYgKCFwYXJlbnRGcmFtZSkge1xuICAgICAgcHJvZ3JhbVsnc3ltYm9scyddID0gU3ltYm9sVGFibGUudG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dyYW1bJ3N5bWJvbHMnXSA9IHBhcmVudEZyYW1lLnN5bWJvbHMhLmNoaWxkKHByb2dyYW0uYmxvY2tQYXJhbXMpO1xuICAgIH1cblxuICAgIGxldCBzdGFydFR5cGU6IHN0cmluZywgZW5kVHlwZTogc3RyaW5nO1xuXG4gICAgaWYgKHRoaXMucHJvZ3JhbURlcHRoID09PSAwKSB7XG4gICAgICBzdGFydFR5cGUgPSAnc3RhcnRQcm9ncmFtJztcbiAgICAgIGVuZFR5cGUgPSAnZW5kUHJvZ3JhbSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0VHlwZSA9ICdzdGFydEJsb2NrJztcbiAgICAgIGVuZFR5cGUgPSAnZW5kQmxvY2snO1xuICAgIH1cblxuICAgIHByb2dyYW1GcmFtZS5wYXJlbnROb2RlID0gcHJvZ3JhbTtcbiAgICBwcm9ncmFtRnJhbWUuY2hpbGRyZW4gPSBwcm9ncmFtLmJvZHk7XG4gICAgcHJvZ3JhbUZyYW1lLmNoaWxkQ291bnQgPSBwcm9ncmFtLmJvZHkubGVuZ3RoO1xuICAgIHByb2dyYW1GcmFtZS5ibGFua0NoaWxkVGV4dE5vZGVzID0gW107XG4gICAgcHJvZ3JhbUZyYW1lLmFjdGlvbnMucHVzaChbZW5kVHlwZSwgW3Byb2dyYW0sIHRoaXMucHJvZ3JhbURlcHRoXV0gYXMgQWN0aW9uKTtcbiAgICBwcm9ncmFtRnJhbWUuc3ltYm9scyA9IHByb2dyYW1bJ3N5bWJvbHMnXTtcblxuICAgIGZvciAobGV0IGkgPSBwcm9ncmFtLmJvZHkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHByb2dyYW1GcmFtZS5jaGlsZEluZGV4ID0gaTtcbiAgICAgIHRoaXMudmlzaXQocHJvZ3JhbS5ib2R5W2ldKTtcbiAgICB9XG5cbiAgICBwcm9ncmFtRnJhbWUuYWN0aW9ucy5wdXNoKFtcbiAgICAgIHN0YXJ0VHlwZSxcbiAgICAgIFtwcm9ncmFtLCBwcm9ncmFtRnJhbWUuY2hpbGRUZW1wbGF0ZUNvdW50LCBwcm9ncmFtRnJhbWUuYmxhbmtDaGlsZFRleHROb2Rlcy5yZXZlcnNlKCldLFxuICAgIF0gYXMgQWN0aW9uKTtcbiAgICB0aGlzLnBvcEZyYW1lKCk7XG5cbiAgICB0aGlzLnByb2dyYW1EZXB0aC0tO1xuXG4gICAgLy8gUHVzaCB0aGUgY29tcGxldGVkIHRlbXBsYXRlIGludG8gdGhlIGdsb2JhbCBhY3Rpb25zIGxpc3RcbiAgICBpZiAocGFyZW50RnJhbWUpIHtcbiAgICAgIHBhcmVudEZyYW1lLmNoaWxkVGVtcGxhdGVDb3VudCsrO1xuICAgIH1cbiAgICB0aGlzLmFjdGlvbnMucHVzaCguLi5wcm9ncmFtRnJhbWUuYWN0aW9ucy5yZXZlcnNlKCkpO1xuICB9XG5cbiAgRWxlbWVudE5vZGUoZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgbGV0IHBhcmVudEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgbGV0IGVsZW1lbnRGcmFtZSA9IHRoaXMucHVzaEZyYW1lKCk7XG5cbiAgICBlbGVtZW50RnJhbWUucGFyZW50Tm9kZSA9IGVsZW1lbnQ7XG4gICAgZWxlbWVudEZyYW1lLmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICBlbGVtZW50RnJhbWUuY2hpbGRDb3VudCA9IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGVsZW1lbnRGcmFtZS5tdXN0YWNoZUNvdW50ICs9IGVsZW1lbnQubW9kaWZpZXJzLmxlbmd0aDtcbiAgICBlbGVtZW50RnJhbWUuYmxhbmtDaGlsZFRleHROb2RlcyA9IFtdO1xuICAgIGVsZW1lbnRGcmFtZS5zeW1ib2xzID0gZWxlbWVudFsnc3ltYm9scyddID0gcGFyZW50RnJhbWUuc3ltYm9scyEuY2hpbGQoZWxlbWVudC5ibG9ja1BhcmFtcyk7XG5cbiAgICBsZXQgYWN0aW9uQXJnczogW0FTVC5FbGVtZW50Tm9kZSwgbnVtYmVyLCBudW1iZXJdID0gW1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhcmVudEZyYW1lLmNoaWxkSW5kZXghLFxuICAgICAgcGFyZW50RnJhbWUuY2hpbGRDb3VudCEsXG4gICAgXTtcblxuICAgIGVsZW1lbnRGcmFtZS5hY3Rpb25zLnB1c2goWydjbG9zZUVsZW1lbnQnLCBhY3Rpb25BcmdzXSk7XG5cbiAgICBmb3IgKGxldCBpID0gZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnZpc2l0KGVsZW1lbnQuYXR0cmlidXRlc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGVsZW1lbnRGcmFtZS5jaGlsZEluZGV4ID0gaTtcbiAgICAgIHRoaXMudmlzaXQoZWxlbWVudC5jaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgbGV0IG9wZW4gPSBbXG4gICAgICAnb3BlbkVsZW1lbnQnLFxuICAgICAgWy4uLmFjdGlvbkFyZ3MsIGVsZW1lbnRGcmFtZS5tdXN0YWNoZUNvdW50LCBlbGVtZW50RnJhbWUuYmxhbmtDaGlsZFRleHROb2Rlcy5yZXZlcnNlKCldLFxuICAgIF0gYXMgQWN0aW9uLk9wZW5FbGVtZW50O1xuICAgIGVsZW1lbnRGcmFtZS5hY3Rpb25zLnB1c2gob3Blbik7XG5cbiAgICB0aGlzLnBvcEZyYW1lKCk7XG5cbiAgICAvLyBQcm9wYWdhdGUgdGhlIGVsZW1lbnQncyBmcmFtZSBzdGF0ZSB0byB0aGUgcGFyZW50IGZyYW1lXG4gICAgaWYgKGVsZW1lbnRGcmFtZS5tdXN0YWNoZUNvdW50ID4gMCkge1xuICAgICAgcGFyZW50RnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIH1cbiAgICBwYXJlbnRGcmFtZS5jaGlsZFRlbXBsYXRlQ291bnQgKz0gZWxlbWVudEZyYW1lLmNoaWxkVGVtcGxhdGVDb3VudDtcbiAgICBwYXJlbnRGcmFtZS5hY3Rpb25zLnB1c2goLi4uZWxlbWVudEZyYW1lLmFjdGlvbnMpO1xuICB9XG5cbiAgQXR0ck5vZGUoYXR0cjogQVNULkF0dHJOb2RlKSB7XG4gICAgaWYgKGF0dHIudmFsdWUudHlwZSAhPT0gJ1RleHROb2RlJykge1xuICAgICAgdGhpcy5jdXJyZW50RnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIFRleHROb2RlKHRleHQ6IEFTVC5UZXh0Tm9kZSkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGlmICh0ZXh0LmNoYXJzID09PSAnJykge1xuICAgICAgZnJhbWUuYmxhbmtDaGlsZFRleHROb2RlcyEucHVzaChkb21JbmRleE9mKGZyYW1lLmNoaWxkcmVuISwgdGV4dCkpO1xuICAgIH1cbiAgICBmcmFtZS5hY3Rpb25zLnB1c2goWyd0ZXh0JywgW3RleHQsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuICB9XG5cbiAgQmxvY2tTdGF0ZW1lbnQobm9kZTogQVNULkJsb2NrU3RhdGVtZW50KSB7XG4gICAgbGV0IGZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG5cbiAgICBmcmFtZS5tdXN0YWNoZUNvdW50Kys7XG4gICAgZnJhbWUuYWN0aW9ucy5wdXNoKFsnYmxvY2snLCBbbm9kZSwgZnJhbWUuY2hpbGRJbmRleCwgZnJhbWUuY2hpbGRDb3VudF1dIGFzIEFjdGlvbik7XG5cbiAgICBpZiAobm9kZS5pbnZlcnNlKSB7XG4gICAgICB0aGlzLnZpc2l0KG5vZGUuaW52ZXJzZSk7XG4gICAgfVxuICAgIGlmIChub2RlLnByb2dyYW0pIHtcbiAgICAgIHRoaXMudmlzaXQobm9kZS5wcm9ncmFtKTtcbiAgICB9XG4gIH1cblxuICBQYXJ0aWFsU3RhdGVtZW50KG5vZGU6IEFTVC5QYXJ0aWFsU3RhdGVtZW50KSB7XG4gICAgbGV0IGZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgZnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIGZyYW1lLmFjdGlvbnMucHVzaChbJ211c3RhY2hlJywgW25vZGUsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuICB9XG5cbiAgQ29tbWVudFN0YXRlbWVudCh0ZXh0OiBBU1QuQ29tbWVudFN0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGZyYW1lLmFjdGlvbnMucHVzaChbJ2NvbW1lbnQnLCBbdGV4dCwgZnJhbWUuY2hpbGRJbmRleCwgZnJhbWUuY2hpbGRDb3VudF1dIGFzIEFjdGlvbik7XG4gIH1cblxuICBNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQoKSB7XG4gICAgLy8gSW50ZW50aW9uYWwgZW1wdHk6IEhhbmRsZWJhcnMgY29tbWVudHMgc2hvdWxkIG5vdCBhZmZlY3Qgb3V0cHV0LlxuICB9XG5cbiAgTXVzdGFjaGVTdGF0ZW1lbnQobXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGZyYW1lLm11c3RhY2hlQ291bnQrKztcbiAgICBmcmFtZS5hY3Rpb25zLnB1c2goWydtdXN0YWNoZScsIFttdXN0YWNoZSwgZnJhbWUuY2hpbGRJbmRleCwgZnJhbWUuY2hpbGRDb3VudF1dIGFzIEFjdGlvbik7XG4gIH1cblxuICAvLyBGcmFtZSBoZWxwZXJzXG5cbiAgcHJpdmF0ZSBnZXQgY3VycmVudEZyYW1lKCk6IEZyYW1lIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuZ2V0Q3VycmVudEZyYW1lKCksICdFeHBlY3RlZCBhIGN1cnJlbnQgZnJhbWUnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q3VycmVudEZyYW1lKCk6IE9wdGlvbjxGcmFtZT4ge1xuICAgIHJldHVybiB0aGlzLmZyYW1lU3RhY2tbdGhpcy5mcmFtZVN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgcHJpdmF0ZSBwdXNoRnJhbWUoKSB7XG4gICAgbGV0IGZyYW1lID0gbmV3IEZyYW1lKCk7XG4gICAgdGhpcy5mcmFtZVN0YWNrLnB1c2goZnJhbWUpO1xuICAgIHJldHVybiBmcmFtZTtcbiAgfVxuXG4gIHByaXZhdGUgcG9wRnJhbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVTdGFjay5wb3AoKTtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRoZSBpbmRleCBvZiBgZG9tTm9kZWAgaW4gdGhlIGBub2Rlc2AgYXJyYXksIHNraXBwaW5nXG4vLyBvdmVyIGFueSBub2RlcyB3aGljaCBkbyBub3QgcmVwcmVzZW50IERPTSBub2Rlcy5cbmZ1bmN0aW9uIGRvbUluZGV4T2Yobm9kZXM6IEFTVC5Ob2RlW10sIGRvbU5vZGU6IEFTVC5UZXh0Tm9kZSB8IEFTVC5FbGVtZW50Tm9kZSkge1xuICBsZXQgaW5kZXggPSAtMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChub2RlLnR5cGUgIT09ICdUZXh0Tm9kZScgJiYgbm9kZS50eXBlICE9PSAnRWxlbWVudE5vZGUnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbiJdfQ==