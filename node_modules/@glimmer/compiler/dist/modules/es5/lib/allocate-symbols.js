var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { Stack } from '@glimmer/util';
export var SymbolAllocator = function () {
    function SymbolAllocator(ops) {
        _classCallCheck(this, SymbolAllocator);

        this.ops = ops;
        this.symbolStack = new Stack();
    }

    SymbolAllocator.prototype.process = function process() {
        var out = [];
        var ops = this.ops;

        for (var i = 0; i < ops.length; i++) {
            var op = ops[i];
            var result = this.dispatch(op);
            if (result === undefined) {
                out.push(op);
            } else {
                out.push(result);
            }
        }
        return out;
    };

    SymbolAllocator.prototype.dispatch = function dispatch(op) {
        var name = op[0];
        var operand = op[1];
        return this[name](operand);
    };

    SymbolAllocator.prototype.startProgram = function startProgram(op) {
        this.symbolStack.push(op['symbols']);
    };

    SymbolAllocator.prototype.endProgram = function endProgram(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.startBlock = function startBlock(op) {
        this.symbolStack.push(op['symbols']);
    };

    SymbolAllocator.prototype.endBlock = function endBlock(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.flushElement = function flushElement(op) {
        this.symbolStack.push(op['symbols']);
    };

    SymbolAllocator.prototype.closeElement = function closeElement(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.closeComponent = function closeComponent(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.closeDynamicComponent = function closeDynamicComponent(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.attrSplat = function attrSplat(_op) {
        return ['attrSplat', this.symbols.allocateBlock('attrs')];
    };

    SymbolAllocator.prototype.get = function get(op) {
        var name = op[0],
            rest = op[1];

        if (name === 0) {
            return ['get', [0, rest]];
        }
        if (isLocal(name, this.symbols)) {
            var head = this.symbols.get(name);
            return ['get', [head, rest]];
        } else if (name[0] === '@') {
            var _head = this.symbols.allocateNamed(name);
            return ['get', [_head, rest]];
        } else {
            return ['maybeLocal', [name].concat(rest)];
        }
    };

    SymbolAllocator.prototype.maybeGet = function maybeGet(op) {
        var name = op[0],
            rest = op[1];

        if (name === 0) {
            return ['get', [0, rest]];
        }
        if (isLocal(name, this.symbols)) {
            var head = this.symbols.get(name);
            return ['get', [head, rest]];
        } else if (name[0] === '@') {
            var _head2 = this.symbols.allocateNamed(name);
            return ['get', [_head2, rest]];
        } else if (rest.length === 0) {
            return ['unknown', name];
        } else {
            return ['maybeLocal', [name].concat(rest)];
        }
    };

    SymbolAllocator.prototype.yield = function _yield(op) {
        if (op === 0) {
            throw new Error('Cannot yield to this');
        }
        return ['yield', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.debugger = function _debugger(_op) {
        return ['debugger', this.symbols.getEvalInfo()];
    };

    SymbolAllocator.prototype.hasBlock = function hasBlock(op) {
        if (op === 0) {
            throw new Error('Cannot hasBlock this');
        }
        return ['hasBlock', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.hasBlockParams = function hasBlockParams(op) {
        if (op === 0) {
            throw new Error('Cannot hasBlockParams this');
        }
        return ['hasBlockParams', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.partial = function partial(_op) {
        return ['partial', this.symbols.getEvalInfo()];
    };

    SymbolAllocator.prototype.text = function text(_op) {};

    SymbolAllocator.prototype.comment = function comment(_op) {};

    SymbolAllocator.prototype.openComponent = function openComponent(_op) {};

    SymbolAllocator.prototype.openElement = function openElement(_op) {};

    SymbolAllocator.prototype.openSplattedElement = function openSplattedElement(_op) {};

    SymbolAllocator.prototype.staticArg = function staticArg(_op) {};

    SymbolAllocator.prototype.dynamicArg = function dynamicArg(_op) {};

    SymbolAllocator.prototype.staticAttr = function staticAttr(_op) {};

    SymbolAllocator.prototype.trustingAttr = function trustingAttr(_op) {};

    SymbolAllocator.prototype.dynamicAttr = function dynamicAttr(_op) {};

    SymbolAllocator.prototype.modifier = function modifier(_op) {};

    SymbolAllocator.prototype.append = function append(_op) {};

    SymbolAllocator.prototype.block = function block(_op) {};

    SymbolAllocator.prototype.literal = function literal(_op) {};

    SymbolAllocator.prototype.helper = function helper(_op) {};

    SymbolAllocator.prototype.unknown = function unknown(_op) {};

    SymbolAllocator.prototype.maybeLocal = function maybeLocal(_op) {};

    SymbolAllocator.prototype.prepareArray = function prepareArray(_op) {};

    SymbolAllocator.prototype.prepareObject = function prepareObject(_op) {};

    SymbolAllocator.prototype.concat = function concat(_op) {};

    _createClass(SymbolAllocator, [{
        key: 'symbols',
        get: function get() {
            return this.symbolStack.current;
        }
    }]);

    return SymbolAllocator;
}();
function isLocal(name, symbols) {
    return symbols && symbols.has(name);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxsb2NhdGUtc3ltYm9scy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9hbGxvY2F0ZS1zeW1ib2xzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFHQSxBQUFPLFNBQUUsQUFBSyxBQUFFLEFBQU0sQUFBRSxhQUFNLEFBQWUsQUFBQztBQWlCOUMsQUFBTSxXQUFPLEFBQWUsQUFJMUI7NkJBQW9CLEFBQWdCO0FBQWhCOzthQUFHLE1BRmYsQUFFWSxBQUFHLEFBQWE7YUFGakIsY0FBRyxJQUFJLEFBQUssQUFBZSxBQUFDLEFBRVIsQUFBQztBQUV4QyxBQUFPOzs7WUFDRCxBQUFHLE1BQVksQUFBRSxBQUFDLEFBQ3RCLEFBQUk7QUFESixZQUNNLEFBQUcsQUFBRSxNQUFHLEFBQUksQUFBQyxBQUVuQjs7YUFBSyxJQUFJLEFBQUMsSUFBRyxBQUFDLEdBQUUsQUFBQyxJQUFHLEFBQUcsSUFBQyxBQUFNLFFBQUUsQUFBQyxBQUFFLEtBQUUsQUFDbkM7Z0JBQUksQUFBRSxLQUFHLEFBQUcsSUFBQyxBQUFDLEFBQUMsQUFBQyxBQUNoQjtnQkFBSSxBQUFNLFNBQUcsQUFBSSxLQUFDLEFBQVEsU0FBQyxBQUFFLEFBQUMsQUFBQyxBQUUvQjtnQkFBSSxBQUFNLFdBQUssQUFBUyxXQUFFLEFBQ3hCLEFBQUc7b0JBQUMsQUFBSSxLQUFDLEFBQVcsQUFBQyxBQUFDLEFBQ3ZCO21CQUFNLEFBQ0wsQUFBRztvQkFBQyxBQUFJLEtBQUMsQUFBYSxBQUFDLEFBQUMsQUFDekI7QUFDRjtBQUVEO2VBQU8sQUFBRyxBQUFDLEFBQ2IsQUFBQztBQUVELEFBQVE7OzJEQUFpQixBQUFLLElBQzVCO1lBQUksQUFBSSxPQUFHLEFBQUUsR0FBQyxBQUFDLEFBQUMsQUFBQyxBQUNqQjtZQUFJLEFBQU8sVUFBRyxBQUFFLEdBQUMsQUFBQyxBQUFDLEFBQUMsQUFFcEI7ZUFBUSxBQUFJLEtBQUMs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S0FBRyxBQUFDLEFBQ3JCOzs7OzRCQWpJRyxBQUFPLEFBQU07bUJBQUMsQUFBSSxLQUFDLEFBQVcsWUFBQyxBQUFPLEFBQUUsQUFBc0MsQUFBQyxBQUFDLEFBQ2xGLEFBQUM7QUFFRCxBQUFZOzs7OztBQWdJZCxTQUFTLEFBQU8sUUFBQyxBQUFZLE1BQUUsQUFBb0IsU0FDakQ7V0FBTyxBQUFPLFdBQUksQUFBTyxRQUFDLEFBQUcsSUFBQyxBQUFJLEFBQUMsQUFBQyxBQUN0QyxBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcGlsZXJPcHMsIFByb2Nlc3NvciwgT3AsIE9wTmFtZSwgVGVtcGxhdGVDb21waWxlck9wcywgUGF0aEhlYWQgfSBmcm9tICcuL2NvbXBpbGVyLW9wcyc7XG5pbXBvcnQgeyBBU1QgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuaW1wb3J0IHsgT3B0aW9uLCBPcGFxdWUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFN0YWNrLCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFN5bWJvbFRhYmxlIH0gZnJvbSAnLi90ZW1wbGF0ZS12aXNpdG9yJztcblxuZXhwb3J0IHR5cGUgSW5WYXJpYWJsZSA9IFBhdGhIZWFkO1xuZXhwb3J0IHR5cGUgT3V0VmFyaWFibGUgPSBudW1iZXI7XG5cbmV4cG9ydCB0eXBlIE91dE9wPEsgZXh0ZW5kcyBrZXlvZiBDb21waWxlck9wczxPdXRWYXJpYWJsZT4gPSBPcE5hbWU+ID0gT3A8XG4gIE91dFZhcmlhYmxlLFxuICBDb21waWxlck9wczxPdXRWYXJpYWJsZT4sXG4gIEtcbj47XG5leHBvcnQgdHlwZSBJbk9wPEsgZXh0ZW5kcyBrZXlvZiBUZW1wbGF0ZUNvbXBpbGVyT3BzID0ga2V5b2YgVGVtcGxhdGVDb21waWxlck9wcz4gPSBPcDxcbiAgUGF0aEhlYWQsXG4gIFRlbXBsYXRlQ29tcGlsZXJPcHMsXG4gIEtcbj47XG5cbmV4cG9ydCBjbGFzcyBTeW1ib2xBbGxvY2F0b3JcbiAgaW1wbGVtZW50cyBQcm9jZXNzb3I8Q29tcGlsZXJPcHM8SW5WYXJpYWJsZT4sIE91dFZhcmlhYmxlLCBDb21waWxlck9wczxPdXRWYXJpYWJsZT4+IHtcbiAgcHJpdmF0ZSBzeW1ib2xTdGFjayA9IG5ldyBTdGFjazxTeW1ib2xUYWJsZT4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wczogQXJyYXk8SW5PcD4pIHt9XG5cbiAgcHJvY2VzcygpOiBPdXRPcFtdIHtcbiAgICBsZXQgb3V0OiBPdXRPcFtdID0gW107XG4gICAgbGV0IHsgb3BzIH0gPSB0aGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBvcCA9IG9wc1tpXTtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRpc3BhdGNoKG9wKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dC5wdXNoKG9wIGFzIE91dE9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dC5wdXNoKHJlc3VsdCBhcyBhbnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBkaXNwYXRjaDxPIGV4dGVuZHMgSW5PcD4ob3A6IE8pOiBPcGFxdWUge1xuICAgIGxldCBuYW1lID0gb3BbMF07XG4gICAgbGV0IG9wZXJhbmQgPSBvcFsxXTtcblxuICAgIHJldHVybiAodGhpc1tuYW1lXSBhcyBhbnkpKG9wZXJhbmQpO1xuICB9XG5cbiAgZ2V0IHN5bWJvbHMoKTogU3ltYm9sVGFibGUge1xuICAgIHJldHVybiBleHBlY3QodGhpcy5zeW1ib2xTdGFjay5jdXJyZW50LCAnRXhwZWN0ZWQgYSBzeW1ib2wgdGFibGUgb24gdGhlIHN0YWNrJyk7XG4gIH1cblxuICBzdGFydFByb2dyYW0ob3A6IEFTVC5Qcm9ncmFtKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wdXNoKG9wWydzeW1ib2xzJ10pO1xuICB9XG5cbiAgZW5kUHJvZ3JhbShfb3A6IG51bGwpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgc3RhcnRCbG9jayhvcDogQVNULlByb2dyYW0pIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnB1c2gob3BbJ3N5bWJvbHMnXSk7XG4gIH1cblxuICBlbmRCbG9jayhfb3A6IG51bGwpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgZmx1c2hFbGVtZW50KG9wOiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnB1c2gob3BbJ3N5bWJvbHMnXSk7XG4gIH1cblxuICBjbG9zZUVsZW1lbnQoX29wOiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgY2xvc2VDb21wb25lbnQoX29wOiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgY2xvc2VEeW5hbWljQ29tcG9uZW50KF9vcDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGF0dHJTcGxhdChfb3A6IE9wdGlvbjxJblZhcmlhYmxlPik6IE91dE9wPCdhdHRyU3BsYXQnPiB7XG4gICAgcmV0dXJuIFsnYXR0clNwbGF0JywgdGhpcy5zeW1ib2xzLmFsbG9jYXRlQmxvY2soJ2F0dHJzJyldO1xuICB9XG5cbiAgZ2V0KG9wOiBbSW5WYXJpYWJsZSwgc3RyaW5nW11dKTogT3V0T3A8J2dldCcgfCAnbWF5YmVMb2NhbCc+IHtcbiAgICBsZXQgW25hbWUsIHJlc3RdID0gb3A7XG5cbiAgICBpZiAobmFtZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFsnZ2V0JywgWzAsIHJlc3RdXTtcbiAgICB9XG5cbiAgICBpZiAoaXNMb2NhbChuYW1lLCB0aGlzLnN5bWJvbHMpKSB7XG4gICAgICBsZXQgaGVhZCA9IHRoaXMuc3ltYm9scy5nZXQobmFtZSk7XG4gICAgICByZXR1cm4gWydnZXQnLCBbaGVhZCwgcmVzdF1dO1xuICAgIH0gZWxzZSBpZiAobmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgICBsZXQgaGVhZCA9IHRoaXMuc3ltYm9scy5hbGxvY2F0ZU5hbWVkKG5hbWUpO1xuICAgICAgcmV0dXJuIFsnZ2V0JywgW2hlYWQsIHJlc3RdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFsnbWF5YmVMb2NhbCcsIFtuYW1lLCAuLi5yZXN0XV07XG4gICAgfVxuICB9XG5cbiAgbWF5YmVHZXQob3A6IFtJblZhcmlhYmxlLCBzdHJpbmdbXV0pOiBPdXRPcDwnZ2V0JyB8ICd1bmtub3duJyB8ICdtYXliZUxvY2FsJz4ge1xuICAgIGxldCBbbmFtZSwgcmVzdF0gPSBvcDtcblxuICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICByZXR1cm4gWydnZXQnLCBbMCwgcmVzdF1dO1xuICAgIH1cblxuICAgIGlmIChpc0xvY2FsKG5hbWUsIHRoaXMuc3ltYm9scykpIHtcbiAgICAgIGxldCBoZWFkID0gdGhpcy5zeW1ib2xzLmdldChuYW1lKTtcbiAgICAgIHJldHVybiBbJ2dldCcsIFtoZWFkLCByZXN0XV07XG4gICAgfSBlbHNlIGlmIChuYW1lWzBdID09PSAnQCcpIHtcbiAgICAgIGxldCBoZWFkID0gdGhpcy5zeW1ib2xzLmFsbG9jYXRlTmFtZWQobmFtZSk7XG4gICAgICByZXR1cm4gWydnZXQnLCBbaGVhZCwgcmVzdF1dO1xuICAgIH0gZWxzZSBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbJ3Vua25vd24nLCBuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFsnbWF5YmVMb2NhbCcsIFtuYW1lLCAuLi5yZXN0XV07XG4gICAgfVxuICB9XG5cbiAgeWllbGQob3A6IEluVmFyaWFibGUpOiBPdXRPcDwneWllbGQnPiB7XG4gICAgaWYgKG9wID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB5aWVsZCB0byB0aGlzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsneWllbGQnLCB0aGlzLnN5bWJvbHMuYWxsb2NhdGVCbG9jayhvcCldO1xuICB9XG5cbiAgZGVidWdnZXIoX29wOiBPcHRpb248SW5WYXJpYWJsZVtdPik6IE91dE9wPCdkZWJ1Z2dlcic+IHtcbiAgICByZXR1cm4gWydkZWJ1Z2dlcicsIHRoaXMuc3ltYm9scy5nZXRFdmFsSW5mbygpXTtcbiAgfVxuXG4gIGhhc0Jsb2NrKG9wOiBJblZhcmlhYmxlKTogT3V0T3A8J2hhc0Jsb2NrJz4ge1xuICAgIGlmIChvcCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGFzQmxvY2sgdGhpcycpO1xuICAgIH1cblxuICAgIHJldHVybiBbJ2hhc0Jsb2NrJywgdGhpcy5zeW1ib2xzLmFsbG9jYXRlQmxvY2sob3ApXTtcbiAgfVxuXG4gIGhhc0Jsb2NrUGFyYW1zKG9wOiBJblZhcmlhYmxlKTogT3V0T3A8J2hhc0Jsb2NrUGFyYW1zJz4ge1xuICAgIGlmIChvcCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGFzQmxvY2tQYXJhbXMgdGhpcycpO1xuICAgIH1cblxuICAgIHJldHVybiBbJ2hhc0Jsb2NrUGFyYW1zJywgdGhpcy5zeW1ib2xzLmFsbG9jYXRlQmxvY2sob3ApXTtcbiAgfVxuXG4gIHBhcnRpYWwoX29wOiBPcHRpb248SW5WYXJpYWJsZVtdPik6IE91dE9wPCdwYXJ0aWFsJz4ge1xuICAgIHJldHVybiBbJ3BhcnRpYWwnLCB0aGlzLnN5bWJvbHMuZ2V0RXZhbEluZm8oKV07XG4gIH1cblxuICB0ZXh0KF9vcDogc3RyaW5nKSB7fVxuICBjb21tZW50KF9vcDogc3RyaW5nKSB7fVxuICBvcGVuQ29tcG9uZW50KF9vcDogQVNULkVsZW1lbnROb2RlKSB7fVxuICBvcGVuRWxlbWVudChfb3A6IEFTVC5FbGVtZW50Tm9kZSkge31cbiAgb3BlblNwbGF0dGVkRWxlbWVudChfb3A6IEFTVC5FbGVtZW50Tm9kZSkge31cbiAgc3RhdGljQXJnKF9vcDogc3RyaW5nKSB7fVxuICBkeW5hbWljQXJnKF9vcDogc3RyaW5nKSB7fVxuICBzdGF0aWNBdHRyKF9vcDogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7fVxuICB0cnVzdGluZ0F0dHIoX29wOiBbc3RyaW5nLCBPcHRpb248c3RyaW5nPl0pIHt9XG4gIGR5bmFtaWNBdHRyKF9vcDogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7fVxuICBtb2RpZmllcihfb3A6IHN0cmluZykge31cbiAgYXBwZW5kKF9vcDogYm9vbGVhbikge31cbiAgYmxvY2soX29wOiBbc3RyaW5nLCBudW1iZXIsIE9wdGlvbjxudW1iZXI+XSkge31cbiAgbGl0ZXJhbChfb3A6IHN0cmluZyB8IGJvb2xlYW4gfCBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkKSB7fVxuICBoZWxwZXIoX29wOiBzdHJpbmcpIHt9XG4gIHVua25vd24oX29wOiBzdHJpbmcpIHt9XG4gIG1heWJlTG9jYWwoX29wOiBzdHJpbmdbXSkge31cbiAgcHJlcGFyZUFycmF5KF9vcDogbnVtYmVyKSB7fVxuICBwcmVwYXJlT2JqZWN0KF9vcDogbnVtYmVyKSB7fVxuICBjb25jYXQoX29wOiBudWxsKSB7fVxufVxuXG5mdW5jdGlvbiBpc0xvY2FsKG5hbWU6IHN0cmluZywgc3ltYm9sczogU3ltYm9sVGFibGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHN5bWJvbHMgJiYgc3ltYm9scy5oYXMobmFtZSk7XG59XG4iXX0=