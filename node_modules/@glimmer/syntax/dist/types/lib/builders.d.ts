import * as AST from './types/nodes';
import { Option } from '@glimmer/interfaces';
export declare type BuilderPath = string | AST.PathExpression;
export declare type TagDescriptor = string | {
    name: string;
    selfClosing: boolean;
};
declare function buildMustache(path: BuilderPath | AST.Literal, params?: AST.Expression[], hash?: AST.Hash, raw?: boolean, loc?: AST.SourceLocation): AST.MustacheStatement;
declare function buildBlock(path: BuilderPath, params: Option<AST.Expression[]>, hash: Option<AST.Hash>, program: AST.Program, inverse?: Option<AST.Program>, loc?: AST.SourceLocation): AST.BlockStatement;
declare function buildElementModifier(path: BuilderPath, params?: AST.Expression[], hash?: AST.Hash, loc?: Option<AST.SourceLocation>): AST.ElementModifierStatement;
declare function buildPartial(name: AST.PathExpression, params?: AST.Expression[], hash?: AST.Hash, indent?: string, loc?: AST.SourceLocation): AST.PartialStatement;
declare function buildComment(value: string, loc?: AST.SourceLocation): AST.CommentStatement;
declare function buildMustacheComment(value: string, loc?: AST.SourceLocation): AST.MustacheCommentStatement;
declare function buildConcat(parts: (AST.TextNode | AST.MustacheStatement)[], loc?: AST.SourceLocation): AST.ConcatStatement;
declare function buildElement(tag: TagDescriptor, attributes?: AST.AttrNode[], modifiers?: AST.ElementModifierStatement[], children?: AST.Statement[], loc?: AST.SourceLocation): AST.ElementNode;
declare function buildElement(tag: TagDescriptor, attributes?: AST.AttrNode[], modifiers?: AST.ElementModifierStatement[], children?: AST.Statement[], comments?: AST.MustacheCommentStatement[], blockParams?: string[], loc?: AST.SourceLocation): AST.ElementNode;
declare function buildAttr(name: string, value: AST.AttrNode['value'], loc?: AST.SourceLocation): AST.AttrNode;
declare function buildText(chars?: string, loc?: AST.SourceLocation): AST.TextNode;
declare function buildSexpr(path: BuilderPath, params?: AST.Expression[], hash?: AST.Hash, loc?: AST.SourceLocation): AST.SubExpression;
declare function buildPath(original: BuilderPath, loc?: AST.SourceLocation): AST.PathExpression;
declare function buildLiteral<T extends AST.Literal>(type: T['type'], value: T['value'], loc?: AST.SourceLocation): AST.Literal;
declare function buildHash(pairs?: AST.HashPair[], loc?: AST.SourceLocation): AST.Hash;
declare function buildPair(key: string, value: AST.Expression, loc?: AST.SourceLocation): AST.HashPair;
declare function buildProgram(body?: AST.Statement[], blockParams?: string[], loc?: AST.SourceLocation): AST.Program;
declare function buildPosition(line: number, column: number): {
    line: number;
    column: number;
};
export declare const SYNTHETIC: AST.SourceLocation;
declare function buildLoc(loc: Option<AST.SourceLocation>): AST.SourceLocation;
declare function buildLoc(startLine: number, startColumn: number, endLine?: number, endColumn?: number, source?: string): AST.SourceLocation;
declare const _default: {
    mustache: typeof buildMustache;
    block: typeof buildBlock;
    partial: typeof buildPartial;
    comment: typeof buildComment;
    mustacheComment: typeof buildMustacheComment;
    element: typeof buildElement;
    elementModifier: typeof buildElementModifier;
    attr: typeof buildAttr;
    text: typeof buildText;
    sexpr: typeof buildSexpr;
    path: typeof buildPath;
    concat: typeof buildConcat;
    hash: typeof buildHash;
    pair: typeof buildPair;
    literal: typeof buildLiteral;
    program: typeof buildProgram;
    loc: typeof buildLoc;
    pos: typeof buildPosition;
    string: (value: string | number | boolean | null | undefined) => AST.Literal;
    boolean: (value: string | number | boolean | null | undefined) => AST.Literal;
    number: (value: string | number | boolean | null | undefined) => AST.Literal;
    undefined(): AST.Literal;
    null(): AST.Literal;
};
export default _default;
